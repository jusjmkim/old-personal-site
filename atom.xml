<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[As I Learn Web Dev]]></title>
  <link href="http://jusjmkim.github.io/atom.xml" rel="self"/>
  <link href="http://jusjmkim.github.io/"/>
  <updated>2014-06-30T09:52:56-04:00</updated>
  <id>http://jusjmkim.github.io/</id>
  <author>
    <name><![CDATA[Justin Kim]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comparing Javascript Objects with Ruby Hashes]]></title>
    <link href="http://jusjmkim.github.io/blog/2014/06/30/comparing-javascript-objects-with-ruby-hashes/"/>
    <updated>2014-06-30T08:37:44-04:00</updated>
    <id>http://jusjmkim.github.io/blog/2014/06/30/comparing-javascript-objects-with-ruby-hashes</id>
    <content type="html"><![CDATA[<p>Having just finished the Javascript track on Codecademy, I felt compelled to comment on at least one aspect of what I learned in the course. Since the two previous languages I learned were Java and Ruby, I found Javascript particularly interesting because it seemed to be a weird mix of the two languages. In this post, I will be looking at the similarities and differences between objects in Javascript and hashes in Ruby. I apologize in advance for any mistakes in this post as while I googled as much as I could to make the information on this accurate, I am still a novice in Javascript.</p>

<p>A comparison of Javascript objects and Ruby hashes came to mind because their syntaxes are extremely similar. One can define a Javascript object through literal notation, as shown below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">key1</span><span class="o">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nx">key2</span><span class="o">:</span> <span class="s2">&quot;value2&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>At the same time, one can define a Ruby hash through literal notation as well.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">key1</span><span class="p">:</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">key2</span><span class="p">:</span> <span class="s2">&quot;value2&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Literally, the only difference in syntax would be the var in front of obj in the Javascript version. In terms of functionality, the two data structures are incredibly similar as they both store data with key-value pairs. In fact, the syntax to call value1 in both structures is incredibly similar.</p>

<p>In Javascript, it would be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">obj</span><span class="p">[</span><span class="s2">&quot;key1&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>and in Ruby, it would be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span><span class="o">[</span><span class="ss">:key1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This difference in syntax hints at one of the subtle differences between these two data structures. In Javascript, the colons are a necessity and simply link corresponding keys and values. In Ruby, however, this syntax implies that the key is a certain data type called a symbol, and in more explicit syntax, the hash can also be declared with hash rockets as such:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">:key1</span> <span class="o">=&gt;</span> <span class="s2">&quot;value1&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">:key2</span> <span class="o">=&gt;</span> <span class="s2">&quot;value2&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For both languages, the key can be data types other than strings or symbols. It is interesting to note that both languages are object oriented languages, and most things are objects in both languages. Thus, it comes as no surprise that hashes in Ruby are also objects. There is a distinction, though, between the construction behind Javascript objects and Ruby hashes since, as the name would imply, Javascript objects represent the general construction behind all objects in Javascript while hashes are just one type of object in Ruby.</p>

<p>The fact that they are both objects is apparent as they can both be declared through constructors. This shows that they are both instances of their respective classes. In Javascript, it would be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>while in Ruby, it would be:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span>
</span></code></pre></td></tr></table></div></figure>


<p>It is interesting to note that values stored in Javascript can be called through the dot notation, as shown below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">key1</span><span class="o">:</span> <span class="nx">value</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">key1</span> <span class="o">===</span> <span class="nx">value</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is exactly the syntax to call an instant variable through a reader method in Ruby (and many other object oriented languages). However, these are not instance variables, so you are not using reader methods. Ultimately, these are two very different data types, but they both store data and have syntaxes so similar that I thought it would be worth mentioning. I&rsquo;m also not entirely sure if the difference between the two is significant, so upon future research (and my remembering to update this post), I will update this information accordingly.</p>

<p>Additional Resources</p>

<p><a href="http://blog.flatironschool.com/post/67666573907/javascript-vs-ruby">http://blog.flatironschool.com/post/67666573907/javascript-vs-ruby</a></p>

<p><a href="http://stantona.github.io/blog/2012/12/12/a-tale-of-two-object-models-javascript-and-ruby/">http://stantona.github.io/blog/2012/12/12/a-tale-of-two-object-models-javascript-and-ruby/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scraping Twitter Timestamps With Nokogiri]]></title>
    <link href="http://jusjmkim.github.io/blog/2014/06/14/scraping-twitter-timestamps-with-nokogiri/"/>
    <updated>2014-06-14T23:40:00-04:00</updated>
    <id>http://jusjmkim.github.io/blog/2014/06/14/scraping-twitter-timestamps-with-nokogiri</id>
    <content type="html"><![CDATA[<p>As test driven development becomes increasingly popular, the desire to test every facet of a piece of a code arises. My group found ourselves in this situation while trying to scrape from Twitter with a Ruby Gem called Nokogiri. However, when we ran our rspec test suite on our code (testing it with one of our twitters), we got this failure:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>expected: <span class="s2">&quot;New blog post about using abstraction and hashes to sort a music collection http://callahanchris.github.io/blog/2014/06/09/abstraction-and-music-library-sorting/ ... @aviflombaum&quot;</span>
</span><span class='line'>got: <span class="s2">&quot;New blog post about using abstraction and hashes to sort a music collection http://callahanchris.github.io/blog/2014/06/09/abstraction-and-music-library-sorting/ ... @aviflombaum&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>These strings look exactly the same to us (the ends of the strings are also identical. I just took a screenshot of part of it too keep it all readable), and we should have been smart and basically considered this test a success. But, this project was more of an educational effort than anything else, and test-driven development dictates that we pass all our tests. Thus, we decided to look into this issue and find another way to test our code. After looking at the tweet&rsquo;s source code, we found this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">&quot;ProfileTweet-contents&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nt">&lt;p</span> <span class="na">class=</span><span class="s">&quot;ProfileTweet-text js-tweet-text u-dir&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="na">dir=</span><span class="s">&quot;ltr&quot;</span><span class="nt">&gt;</span>New blog post about using abstraction and hashes to sort a music collection
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;http://t.co/jRE2HgXYgi&quot;</span> <span class="na">rel=</span><span class="s">&quot;nofollow&quot;</span> <span class="na">dir=</span><span class="s">&quot;ltr&quot;</span>
</span><span class='line'>    <span class="na">data-expanded-url=</span><span class="s">&quot;http://callahanchris.github.io/blog/2014/06/09/abstraction-and-music-library-sorting/&quot;</span>
</span><span class='line'>    <span class="na">class=</span><span class="s">&quot;twitter-timeline-link&quot;</span> <span class="na">target=</span><span class="s">&quot;_blank&quot;</span> <span class="na">title=</span><span class="s">&quot;http://callahanchris.github.io/blog/2014/06/09/abstraction-and-music-library-sorting/&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;tco-ellipsis&quot;</span><span class="nt">&gt;&lt;/span&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;invisible&quot;</span><span class="nt">&gt;</span>http://<span class="nt">&lt;/span&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;js-display-url&quot;</span><span class="nt">&gt;</span>callahanchris.github.io/blog/2014/06/0<span class="nt">&lt;/span&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;invisible&quot;</span><span class="nt">&gt;</span>9/abstraction-and-music-library-sorting/<span class="nt">&lt;/span&gt;</span>
</span><span class='line'>    <span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;tco-ellipsis&quot;</span><span class="nt">&gt;&lt;span</span> <span class="na">class=</span><span class="s">&quot;invisible&quot;</span><span class="nt">&gt;</span><span class="ni">&amp;nbsp;</span><span class="nt">&lt;/span&gt;</span>â€¦<span class="nt">&lt;/span&gt;&lt;/a&gt;</span>
</span><span class='line'>    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">&quot;/aviflombaum&quot;</span> <span class="na">class=</span><span class="s">&quot;twitter-atreply pretty-link&quot;</span> <span class="na">dir=</span><span class="s">&quot;ltr&quot;</span> <span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;s&gt;</span>@<span class="nt">&lt;/s&gt;&lt;b&gt;</span>aviflombaum<span class="nt">&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>It seems that while the strings seem to be displaying the same, the actual output is still a Nokogiri XML output. If that was true, we couldn&rsquo;t go about validating the tweet directly. I wasn&rsquo;t sure what to do to test my code until I saw this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;span</span> <span class="na">class=</span><span class="s">&quot;js-short-timestamp &quot;</span>
</span><span class='line'>  <span class="na">data-time=</span><span class="s">&quot;1402347168&quot;</span>
</span><span class='line'>  <span class="na">data-long-form=</span><span class="s">&quot;true&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  Jun 9
</span><span class='line'><span class="nt">&lt;/span&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Perhaps, we can confirm my code with each tweet&rsquo;s timestamp since every tweet, in theory, has a unique timestamp. After much Nokogiri work, we reached the result below, and it outputted a list of timestamps. (@student_twitters is simply an array of each student&rsquo;s twitter handle urls.)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">time_stamp</span>
</span><span class='line'>  <span class="n">time_stamps</span> <span class="o">||=</span> <span class="vi">@student_twitters</span><span class="o">.</span><span class="n">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">twitter_profile</span><span class="o">|</span>
</span><span class='line'>    <span class="n">page</span> <span class="o">=</span> <span class="ss">Nokogiri</span><span class="p">:</span><span class="ss">:HTML</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">twitter_profile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="n">time_stamp</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s2">&quot;span.js-short-timestamp&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">{</span><span class="o">|</span><span class="n">stamp</span><span class="o">|</span> <span class="n">stamp</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="s2">&quot;data-time&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>It is important to note that while Nokogiri outputs all of these in square brackets, the output does not behave like an array at all. To be perfectly honest, I am not particularly well-versed in Nokogiri enough to explain why or definitively what is happening under the hood, but most array methods don&rsquo;t seem to work on the entire output. Rather, most methods used on the output only seem to target the first element. As shown in the rspec test suite below, we simply called the second element of the list via its index and asked if it included a timestamp I knew was there.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">describe</span> <span class="s2">&quot;#student_tweets&quot;</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">it</span> <span class="s2">&quot;contains tweets of students&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">expect</span><span class="p">(</span><span class="n">twitter_scrape</span><span class="o">.</span><span class="n">time_stamp</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="kp">include</span><span class="p">(</span><span class="s2">&quot;1402606534&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The code now passed its test suite! Furthermore, if one ever wanted to confirm the equality of twitter instances, on can do so as shown below.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">==</span><span class="p">(</span><span class="n">other_tweet</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">self</span><span class="o">.</span><span class="n">time_stamp</span> <span class="o">==</span> <span class="n">other_tweet</span><span class="o">.</span><span class="n">time_stamp</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Nokogiri is fairly troublesome to use on large html documents, and knowing which css selectors to target and how to test for it may prove to be useful. I hope this post has proven to do just that for at least some of those who have bothered to read this far.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My First Post On Octopress]]></title>
    <link href="http://jusjmkim.github.io/blog/2014/06/03/my-first-post-on-octopress/"/>
    <updated>2014-06-03T23:17:46-04:00</updated>
    <id>http://jusjmkim.github.io/blog/2014/06/03/my-first-post-on-octopress</id>
    <content type="html"><![CDATA[<p>&ldquo;Hello, World!&rdquo;</p>
]]></content>
  </entry>
  
</feed>
